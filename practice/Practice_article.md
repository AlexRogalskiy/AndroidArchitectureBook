Раунд практических вопросов в виде "Проблема-Решение". <br>
Некоторые вопросы перекликаются с теми, что были рассмотрены в Теории.<br>

----------

**Проблема** <br>
Организация DI  в  проекте. Какая сущность ответственна за создание и удаление компонента?<br>

**Решение**<br>
Ответ от одного из участников чата, на примере популярного фреймворка Dagger 2. <br>
В Application хранится ссылка на ComponentManager. Его задача инициализировать и отдавать компоненты по запросу. Есть AppComponent, который предоставляет базовые зависимости, которые нужны везде. Его мы обычно Singleton скопом помечаем. Далее используем subComponent с другими скоупами, жизненным циклом которых мы управляем сами через componentManager. SubComponent продумываем таким образом, чтобы он использовался для конкретных задач логически связанных. <br>
Например, нам нужен компонент, который будет предоставлять зависимости только для работы с новостройками (это из нашего проекта). Т.е этот компонент предоставляет нам все необходимые классы для работы с новостройками/конкретной новостройкой, фильтрами и т.д. (Презентер, Интерактор, Репозиторий и прочие вспомогательные классы). Соответственно нам нужен компонент, и вот тут идет в ход componentManager и subComponent. Мы открываем активити или фрагмент, отвечающая за новостройки, и в методе onCreate просим componentManager предоставить нужный компонент. Пусть будет BuildingsComponent. Чтобы память не текла нужно сабкомпоненты занулять когда активити финиширует (это делает все тот же componentManager, т.к ссылки на компоненты хранятся в нем). В данном активити/фрагменте инжектим Презентер, а далее происходит уже инициализация всего дерева зависимостей BuildingsComponent.<br>
**Главная мысль:** компоненты Даггера должны храниться в специальном контейнере синглтоне, например, ComponentManager.  <br>

#DI #Dagger2<br>


----------

**Проблема**<br>
 Детальный пример, показывающий, как писать с использованием Чистой архитектуры. Как создаются слои, и за что каждый класс отвечает?<br>

**Решение**<br>
Рекомендуем серию статей:<br>

[Android Architecture: Part 1 -  every new beginning is hard](http://five.agency/android-architecture-part-1-every-new-beginning-is-hard/) <br>
[Android Architecture: Part 2 - the clean architecture](http://five.agency/android-architecture-part-2-clean-architecture/)<br>
[Android Architecture: Part 3 - Applying clean architecture on Android](http://five.agency/android-architecture-part-3-applying-clean-architecture-android/)<br>
[Android Architecture: Part 4 - Applying Clean Architecture on Android, Hands on (source code included)](http://five.agency/android-architecture-part-4-applying-clean-architecture-on-android-hands-on/)<br>
[Android Architecture: Part 5 - How to Test Clean Architecture](http://five.agency/android-architecture-part-5-how-to-test-clean-architecture/)<br>

Очень грамотное теоретическое описание трансформации классической Clean Architecture от дядюшки Боба в Clean Architecture для Android. <br>
Единственное, вторая статья как-то немного запутала с этими input/output портами для UseCase и решением проблемы флоу данных через наследование и композицию. Немного оторвано от практики, как мне показалось. Лучше сразу к третьей части приступить, если вы также не совсем поняли.<br>
Еще есть моменты, над которыми можно похоливарить.<br>

#пример #статьи<br>

----------

**Проблема**<br>
Как проектировать? Сверху вниз или снизу вверх?<br>

**Решение**<br>
Лучше первый вариант, так как он быстрее позволяет получить первый результат в виде работающего приложения, пускай и с моками.<br>

#проектирование<br>


----------


**Проблема**<br>

Как организовать поведение схожее с Инстаграмом. То есть ты ставишь лайк, и на UI сразу же все отображается. При этом параллельно идет запрос, прочая логика. И в конце концов запрос может провалиться. <br>

**Решение**<br>

Варианты решения.<br>

1. Локальное состояние как single source of truth. UI мониторит локальное состояние - подписывается на Subject/Flow. Это может быть кэш в памяти или база данных. Room так вообще из коробки может выдавать Observable/Flow для SQL-запросов.
Пользователь жмакает like. Локальное состояние немедленно обновляется и UI получает update (он же подписан, значит автоматом прилетит обновление).
В этот момент асинхронно идёт запрос на сервер. Если он ок, то всё, ничего не трогаем. Если не ок, то откатываем локальное состояние, UI получает update - откат, и можем пользователю показать сообщение об ошибке (toast, например).
Тут получится так, что лайк мигнёт, но это ок. Многие соцсети так и делают.<br>

2. Вариант с откатом состояния UI можно сделать и без локального состояния. Просто сразу обновляем UI и откатываем в случае фэйла запроса. Тут может быть проблема если одно и то же состояние отображается в разных местах. Например, лайки могут быть в ленте, при открытии поста, так же есть счётчик лайков. И все эти отображения надо не забыть обновлять и откатывать в случае ошибки. Поэтому вариант с единым состоянием и мониторингом его выглядит предпочтительнее.<br>

3. Можно складывать запросы в очередь в базу и синхронизировать по возможности. Этот вариант сложен в реализации. И пользователь может долго не узнать, что у него проблемы с соединением. Поэтому его стоит рассматривать если пользователь реально должен что-то делать в оффлайне и понимает, что синхронизация может произойти не сразу.<br>

4. Так же iOS кидали в сторону CQRS<br>
http://blog.softmemes.com/2016/11/12/using-cqrs-with-event-sourcing/<br>
https://martinfowler.com/bliki/CQRS.html<br>

#CQRS<br>


----------

**Проблема**<br>

Структура пакетов и размещение файлов. Должны ли интерфейсы быть отделены от имплементаций, или они могут находиться в одном пакете?<br>

**Решение**<br>

В проектах с чистой архитектурой, чаще всего пакеты формируют по фичам или слоям. Примеры есть в статье http://www.javapractices.com/topic/TopicAction.do?Id=205.<br>
Примерная структура проекта может быть такой:<br>
```
project
├─ di
│  ├─ app
│  ├─ payments
│  └─ operation
├─ presentation
│  ├─ view
│  │  ├─ payments
│  │  │  ├─ PaymentsView
│  │  │  └─ PaymentsFragment
│  │  └─ operations
│  │     ├─ OperationsView
│  │     └─ OperationsFragment
│  └─ presenter
│     ├─ payments
│     │  └─ PaymantsPresenter
│     └─ operations
│        └─ OperationsPresenter
├─ domain (он же business)
│  ├─ payments
│  │  ├─ PaymentsInteractor
│  │  ├─ PaymentsInteractorImpl
│  │  └─ CurrencyHandler (вспомогательный класс для PaymentsInteractor)
│  └─ operations
│     ├─ OperationsInteractor
│     ├─ rubs
│     │  ├─ OperationsInteractorRubs
│     │  └─ RubsManager (вспомогательный класс для OperationsInteractorRubs)
│     └─ currency
│        ├─ OperationsInteractorCurr
│        └─ CurrencyManager (вспомогательный класс для OperationsInteractorCurr)
├─ repositories
│  ├─ payments
│  │  ├─ PaymentsRepository
│  │  └─ PaymentsRepositoryImpl
│  └─ operations
│     ├─ OperationsRepository
│     └─ OperationsRepositoryImpl
├─ data
│  ├─ network
│  └─ db
└─ models (по сути хранилище всех dto)
   ├─ payments
   │  ├─ PaymentsModel
   └─ operations
      ├─ presentation
      │  └─ OperationUIModel
      ├─ domain
      │  ├─ OperationsRubModel
      │  └─ OperationCurrModel
      └─ data
         ├─ OperationsRubNetworkModel
         └─ OperationCurrNetworkModel
```

Разбивать только по слоям или фичам не всегда бывает удобно, поэтому гибридный вариант, когда внутри одного пакета слоя могут быть пакеты с фичами, вполне приемлем.<br>

Иногда проект разбивают на модули, чаще всего делаю отдельный модуль для каждого слоя приложения. <br>

Подробнее в нашей Теории.<br>

#структура #общиепрактики <br>

----------

**Проблема**<br>

Нужен ли Dagger 2 для реализации DI? В чем профит данной библиотеки?<br>
 
**Решение**<br>

Dagger 2 не является необходимым условием для реализации DI. Но многие специалисты (например, Марк Симан в книге Dependency Injection in .NET) настоятельно рекомендуют использовать готовое решение для реализации DI. Реализацию DI без использования библиотеки называют "DI для бедных".<br>
Dagger 2 имеет следующие преимущества перед "ручной" реализации:<br>

 - Управление жизненным циклом зависимостей<br>
 - Генерация кода для создания зависимостей<br>

Еще поговаривают про [toothpick](https://github.com/stephanenicolas/toothpick), как альтернативу Даггера.<br>

#DI #библиотеки #Dagger2<br>

----------

**Проблема**<br>

Что делать, если клиент для работы с БД или сетью может поменяться?<br>
 
**Решение**<br>

Если мы знаем, что работа с бд у нас может поменяться, то можем ввести специальный DbFacade, скажем. У него будет единый интерфейс, но две разные реализации. Получается, что DbFacade будет посредине между репозиторием и непосредственно работой с БД. Таким образом, Репозиторий просто дергает этот DBFacade, а как именно идут в БД запросы, его не волнует. Кроме того Фасад будет отдавать в Репозиторий какую-то единую модель. То есть у каждого клиента могут быть свои модели для запросов и ответов, но наружу отдается какая-то единая. Это все для того, чтобы внедрение нового клиента проходило максимально безболезненно.

#repository #designpatterns<br>

----------

**Проблема**<br>

Репозиторий и его место?<br>
 
**Решение**<br>
Начнем с того, что понятие "Репозиторий" несколько трансформировалось в Андроиде. Более подробно лучше почитать [здесь ](http://hannesdorfmann.com/android/evolution-of-the-repository-pattern).<br>
В чистой архитектуре дядюшки Боба интерфейсы репозиториев принадлежат слою бизнес-логики. А реализация интерфейсов к слою Дата. Бизнес-логика ничего не знает о моделях Даты, она получает уже готовые бизнес-модели. Репозиторий отвечает за маппинг данных, выбор источников данных, а также за кеширование. Интерактору выдается просто готовые модели. <br>
Есть возражения, что если осуществлять еще и кеширование, то как-то много всего будет в Репозитории. Ну тут остается только посоветовать - делегируйте во вспомогательные классы. У Фернандо показан хороший пример делегирования через Фабрику и DataStore (в [статье Ханнеса](http://hannesdorfmann.com/android/evolution-of-the-repository-pattern), раздел Evolution of the Repository Pattern term). Там фабрика решает, какой DataStore задействовать для конкретного id. <br>
Если для принятия решения о кешировании нужна информация с другого Репозитория, то пускай Интерактор передаст через аргумент метода нужную инфу в Репозиторий. Вообщем тут Интерактор отвечает за взаимодействием и необходимый обмен информацией между Репозиториями. Например у одного репозитория запросил, какой режим сейчас (пользовательский или демо), а в другой репозиторий передал эти данные для получения корректного списка операций.<br>

``` java
modeRepository.getMode()
    .flatMap(mode -> operationsRepository.getOperations(mode))
```

Исходя из вышесказанного, Репозиторий должен тестироваться.<br>
Если вам нужно сделать приложение быстро, можно, конечно, не заморачиваться с маппингом, а передавать модель, полученную с запроса. Но если приложение чуть более серьезное и долгое, то лучше маппить. Так как по опыту, в Дата-уровне или в логике получения данных всегда что-то может поменяться. Бизнес-логика про это вообще не должна знать.<br>

#repository #designpatterns<br>

----------

**Проблема**<br>

Работа с кешом и  со списком. Как данные получать, где хранить список (презентер, репозиторий), как обрабатывать ЖЦ?<br>
 
**Решение**<br>

Любые данные, которые хранятся во View могут быть потеряны, если не предпринять мер для их сохранения. Сохранение данных, которые находятся во View является настолько частым кейсом для Android, что из коробки предоставляются некоторые инструменты для сохранения и восстановления данных. Однако по  ряду причин, такие инструменты не всегда удобны.<br>

 1. Возможные утечки памяти<br>
 2. Необходимость реализации Parcelable<br>
 3. Такие инструменты, как Loader навязывают противоречивые подходы <br>

На наш взгляд, эффективнее решения, которые основаны на том, что данные, сетевые и локальные запросы будут хранится в компонентах, которые переживают View. Например, на таком подходе основана MVP библиотека [Moxy](https://github.com/Arello-Mobile/Moxy). <br>

#lifecycle #design-patterns<br>

----------

**Проблема**<br>

Где должны располагаться Android не UI классы (ContactProvider, CallendarProvider, GoogleApiClient, Service)? <br>

**Решение**<br>

Мы думаем, что такие классы должны использоваться  в Data слое на уровне с той же сетью или БД. Этим мы добиваемся того, что в бизнес-логике не будет Android классов. Ну и плюс получается вполне корректное разделение по слоям.<br>
Причем пользователи Репозитория не должны догадываться, что для получения данных, под капотом используется, например Сервис.<br>
Как это примерно выглядит.<br>
Есть интерфейс Репозитория. Скажем, IAppRepository<br>
У него есть метод :<br>

```java
public Observable<Point> getLocation()
```

В конкретной реализации интерфейса - AppRepository будет такой код примерно:<br>

```java
public Observable<Point> getLocation() {
    return geoApiProvider.getLocation()
}
```

geoApiProvider - это специальный класс, которому мы делегируем работу с сервисом и т.д.  Внутри у этого класса будет работа с сервисом и Subject, через который будут отдаваться данные. Заметим, что наружу мы выдаем не Subject, а Observable - ни к чему пользователям знать большее.<br>
Могут быть вопросы по тому, а как потом убить сервис, если он стартующий, например.<br>
Желательно, конечно, спроектировать так, чтобы убийство происходило автоматом, например, при отписке последнего подписчика.  Все зависит от задачи.<br>

#service #repository #designpatterns<br>

----------

**Проблема**<br>

Хранение данных в рантайме.  Если нужно хранить какие-то состояния, но класть их в БД или SP нет необходимости. А где мне следует хранить данные, которые должны жить только в рантайме? Т.е. допустим, у меня приложение не кэширует что-то в бд. Получает данные и хранит пока приложение живо. У меня есть репозиторий, в нем по сути ретрофит, который берет данные из сети. Репозиторий сделал на случай если бд в дальнейшем понадобится, то будет удобно делать выборку из бд или сети в репозитории. А данные которые, хранятся в рантайме я тоже в репозитории хранить должен или какой-то манагер данных должен быть, в которого складываются данные из сети?<br>

**Решение**<br>

Persistence данные должны быть всегда сокрыты под Репозиторием. <br>
Если есть данные, которые вы пока храните Runtime, но потом скорее всего потом будете Persistence, то эти данные можно сокрыть под Репозиторием и хранить их, например, в HeapStorage.<br>

#repository #designpatterns<br>

----------

**Проблема**<br>

Большой интерактор (Интерактор в понимании UseCase feature facade). Куда выносить код из интеракторов? У меня в одном уже 1000 строк кода, и это еще Rx + Retrolambda. Методы только те, которые выполняют какие-либо операции на экране.<br>

**Решение**<br>

Можно реализовать интерактор по паттерну Фасад. Данный интерактор будет уже дергать соответствующие вспомогательные классы. И интерфейс бизнес-логики у нас будет единым, что очень удобно при дальнейшем сопровождении. <br>
По опыту одного из админов. Была задача встроить чат в одно банковское приложение. И там было очень много логики. Но так как это одна бизнес-фича, то был сделан один Интерактор по Фасаду. В имплементации он по сути просто дергал вспомогательные классы. Написаны были ещё некоторые функциональные тесты. И вот спустя 9 месяцев руководство для реализации чата решило использовать не стороннюю либу, а свою. А это другой интерфейс и вообще другая логика отправки сообщений и прослушки входящих. Поэтому просто подменой data уровня было не спастись. Но ui тот же остаётся. <br>
И вот тогда действительно сыграло на руку такое решение с интерактором. Была просто произведена подмена Интерактора без затрагивания View и Presenters, где было тоже немало всего. И оно заработало с первого раза =)<br>

#facade #interactor #designpatterns<br>

----------

**Проблема**<br>

Презентер и Интерактор. Могут ли быть в Презентере сразу несколько Интеракторов?<br>

**Решение** <br>

Зависит от ситуации. Если для обработки ЖЦ вы используете специальные библиотеки типа Moxy, и вам ничего не нужно кешировать и как-то обрабатывать возможные нестыковки при переориентации экрана, то жизнь заметно упрощается, и тогда в Презентере можно стыковать несколько Интеракторов. <br>
Но опять-таки, только стыковать. Если необходимо добавлять какую-то бизнес-логику, выносите это в Интеракторы.<br>

#presenter #interactor<br>

----------

**Проблема**<br>

One direction flow. Частая ошибка - презентер становится хелпером для вью.<br>

**Решение**<br>
На наш взгляд, правильное применение MVP заключается в следующем (только о взаимодействии верхних слоев - Presenter и View):<br>
1) One direction data flow, методы в интерфейсе View должны иметь только методы, которые возвращают void) <br>
2) Распределение ответственности: View - представление и никакой логики. Presenter - обработка событий View <br>
3) Чувство меры: как и в любой технологии тут важно уметь остановиться. Прокидывание абсолютно всего через презентер создают метод-хелл.<br>
Часто встречается в Презентере код типа view.getSearchString. Презентер ничего не должен возвращать в своих методах, так как вьюха должна быть глупой, и не ей решать когда и что получать. Нужно будет - презентер сам ей данные передаст, и скажет что с ними делать.<br>
View ничего не возвращает, потому что:<br>
а) View может и не быть<br>
б) Иногда View может быть несколько, с какой брать?<br>
в) Самое главное - View с презентером работает по событийной модели: если презентер должен реагировать на изменение в EditText, то View должна сказать что текст поменялся, и передать текущий текст. Это как в армии - есть караульный (View), есть начальник караула (презентер). Начальник караула не должен постоянно опрашивать караульных, что у тех происходит. Наоборот, это караульный, если что-то произошло, должен доложить начальнику.<br>
#onedirectionflow #mvp<br>
----------


**Проблема**<br>
Есть следующая задача: перед каждым 4-ым вызовом некоторого апи нужно показывать рекламный блок. Как правильно сделать?<br>

**Решение**<br>
Проверка на уровне интерактора. То есть у репозитория два метода: getData и getAds.<br>
А интерактор считает когда нужно показывать данные, а когда рекламу, в нём логика.<br>

#бизнес-логика<br>

----------

**Проблема**<br>
Есть RecyclerView с различными разнообразными ViewHolder. В одном item списка может быть семь EditText, в другом - другие компоненты. У каждого item своя логика валидации и прочее. Возникает риск распухания ViewHolder'ов и намешивания в них бизнес-логики. <br>

**Решение**<br>
Советуем посмотреть в сторону [решения](http://hannesdorfmann.com/android/adapter-delegates), описанного у Дорфмана.<br>
Библиотека позволяет создавать классы - делегаты для вашего адаптера. Для отображения элемента списка библиотека умеет находить нужный делегат, зарегистрированный в DelegatesManager. Таким образом в коде адаптера отсутствуют конструкции switch или else if для выбора типа элемента, а добавление новых типов элементов становится очень простым.<br>
В делегаты вы можете инжектить Презентеры, через которые провайдите действия пользователя. Однако бывают случаи, когда один item переиспользуется во многих местах, и этот item отвечает, например, за "like". Инжектить Презентер бывает не очень удобно, так как тогда возникает дублирование кода и протягивание лишних зависимостей, чтобы в конце концов выполнить нужный UseCase. <br>
Поэтому можно заинжектить в данный делегат специальный Интерактор, который как раз и выполняет нажатия.<br>

#библиотеки #adapter-delegates #recyclerview<br>


----------


**Проблема**<br>
А как правильно реализовывать логику выбора данных из кэша или из сети? Что если иногда надо брать из кэша, а иногда из сети? Правильно ли делать в репозитории методы типа getfromnetwork и getfromcache? Например в случае если pull-to-refresh ту рефреш, то это обязательно из сети, а в каких-то других случаях можно и из кэша взять. Или  например есть ситуация: есть объект, мне сначала нужно сделать бизнес-операцию над ним, далее показать, паралельно отправить запрос в облако, для обновления данных об объекте, и когда запрос выполнится, отобразить актуальные данные из сети. По сути мне нужно знать о существовании разных источников данных на уровне бизнес логики. Тогда какая часть должна быть в репозиторие?<br>

**Решение**<br>
Логика получения данных, в общем случае, хранится в специальном классе на уровне модели. Далее возможно иметь 2 кейса:<br>
1) Менеджер источников данных (например, SmthDataStoreFactory) инжектится в SmthRepository и сам решает, как вытаскивать данные - из сети или кэша.<br>
2) В случае, когда бизнес логике важно, чтобы данные пришли свежими, отправляется специальный флаг типа "needFreshData", его получает менеджер и понимает, что кэш в данном случае не прокатит, делает запрос на сервер. Если нужна более гибкая настройка, можно использовать различные стратегии для выборки данных, FirstCache, NoCache и т.д.. В репозитории будут методы с сигнатурой,  getUser(int id, boolean needFreshData) или getUser(int id, CachePolicy policy).<br>

Методы, вроде  getfromnetwork и getfromcache использовать можно, у такого подхода есть плюс, по сравнению с подходом, когда используется менеджер источников данных (SmthDatatStoreFactory) - не будет заглушек вроде UnsupportedOperationException на методы, которые актуальны для одних источников, но не поддерживаются в других. Из минусов, не получится, поменять источник данных, не затронув при этом реализации зависящих классов.<br>

#repository #design-patterns #бизнес-логика<br>

----------

**Проблема**<br>
Мне необходимо загрузить список (есть local и remote data source). Т.е. сначала необходимо отобразить данные из local, и потом делать запрос к серверу. Является ли это бизнес-логикой, или эту логику необходимо вынести в Repository?<br>

**Решение**<br>
Зависит от требований к приложению, глобально есть два подхода:<br>
1) умный кэш (тогда это на уровне репозитория, а интерактор только просит данные);<br>
2) глупый репозиторий (репозиторий только знает как достать данные, а интерактор сам говорит откуда и когда);<br>

#repository #design-patterns #бизнес-логика<br>

----------

**Проблема**<br>
После некоторого действия пользователя показывается SnackBar с кнопкой Отмена. Если успеть ее нажать, то действие надо отменить. Как лучше это сделать.<br>

**Решение**<br>
Презентер сообщает действие интерактору только по событию: "SnackBar скрылся", то есть только после того как пользователь решил не отменять действие. Важно: надо заранее учесть, что пользователь может сразу после действия выйти с экрана или приложения. Тогда надо принять решение - либо также передать действие интерактору при деттаче вью, либо считать такое поведение пользователя тоже отменой действия.<br>

#бизнес-логика<br>

----------

**Проблема**<br>
Есть список элементов. По клику открывается информация о конкретном элементе. Можно ли передавать элемент через параметры нового экрана или надо в параметры класть только Id?<br>

**Решение**<br>
Правильнее передавать параметром только Id, а сами элементы будут закэшированы в репозитории.<br>
Так как в этом случае мы сможем получить всегда актуальную информацию из репозитория, а не устаревшую из параметров.<br>

#общие-практики<br>


----------

**Проблема**<br>
Может ли Presenter обращаться к Interactor за некоторыми константами (Interactor.ROOT_FOLDER_ID)?<br>

**Решение**<br>
Лучше чтобы презентер не знал о каких-то константах бизнес логики.<br>
Если эта константа дальше нужна для получения данных, то лучше сделать явный метод getRootFolderInfo() или что-то в этом роде.<br>

#бизнес-логика<br>


----------

**Проблема**<br>
Необходимо в тексте подсветить некоторые части с помощью спанов.<br>
Это бизнес логика, как лучше поступить?<br>

**Решение**<br>
Передавать из презентера массив пар строка-цвет и отрисовывать во вью.<br>
Или передавать всю строку, и массив из выделений (индекс начала, индекс конца, цвет)<br>

#бизнес-логика<br>

----------

**Проблема**<br>
Использовать контекст в Презентере и Интеракторе или нет? <br>

**Решение**<br>
Мы рекомендуем не использовать контекст в классах с бизнес-логикой. Так как, используя контекст в классах с бизнес-логикой мы нарушаем правило зависимостей (зависимости направлены в одну стороны, от внешних слоев ко внутренним). Если есть необходимость в платформозависимых классах в презентере или интеракторе, то можно воспользоваться инверсией зависимостей и передать в класс интерфейс для доступа к платформозависимому классу, а реализацию оставить в слое дата или представления. <br>
Приведем пример, нам нужно локализованную строку  из Презентера передать во View.  Без контекста вроде никак. И тут мы добавляем зависимость. И это только для получения строчки, не более. Но проблема в том, что последователи могут начать использовать контекст в Презентере не по назначению. А если контекст будет в Интеракторе, то теоретически наша бизнес-логика будет завязана на конкретную платформу, что делает ее не переиспользуемой (кейс переиспользования бизнес-логики где-то в другом месте, конечно, очень редкий в нашем мобильном мире, но все же).<br>
На самом деле есть способы избежать использования контекста в том же Презентере. <br>
Для доступа к ресурсам надо создать отдельную сущность, которая будет работать с контекстом только ради ресурсов, типа ResourceManager, и все. <br>
Проблема решаема, причем довольно малой кровью. Но зато наш код чистый и независимый.<br>

#context #dependency-inversion #resource-manager<br>

----------

**Проблема**<br>

 В каких классах делать выбор Scheduler'ов?<br>

**Решение**<br>

Если посмотреть лекции дядюшки Боба, интерактор отвечает за бизнес логику и ничего не знает о внешних фреймворках, ui, db.<br>
То, что Андроид обязан работать с View только в главном потоке, знает только сам Андроид фреймворк. Соответственно, обязанность предоставить шедулер Android.mainThread() должна лежать снаружи от интерактора.<br>
Обязанность презентера - координировать вью и модель. Если вью необходимо, чтобы данные обрабатывались в главном потоке - мы явно указываем observeOn(AndroidSchedulers.mainThread()).<br>
SubscriveOn() происходит уже в интеракторе, или репозитории, которые владеют необходимой информацией о том, стоит ли выделить новый поток (который будет уже Андроид-независимым, как Schedulers.Io() или Schedulers.computation()).<br>

Пример:<br>

Презентер:<br>

```java
userInteractor.downloadUserInfo()
  .map(mapper::entityToView);
  .observeOn(AndroidSchedulers.mainThread())
  .subscribe(view::showUserInfo);
```

Интерактор:<br>

```java
repository.downloadUserInfo();
```

Репозиторий (в более сложном кейсе, Schedulers зависи от источника данных, тут упрощённый пример с нетворком):<br>

```java
api.downloadUserInfo()
  .subscribeOn(Schedulers.io)
  .map(mapper::networkToEntity);
```

Переключение потоков может быть как частью бизнес-логики, так и частью слоя данных. Зависит от того, какой класс имеет необходимую информацию для принятия решения.<br>
При передаче между слоями можно всегда прокидывать данные через главный поток - таким образом, при получении observable в новом слое мы знаем, на каком потоке он выполнится. Минус подхода - зачастую, будут излишние переключения.<br>

#rxjava

----------

**Проблема**<br>
От сервера в Repository приходит флаг, по которому необходимо разлогинить пользователя. Но перед этим мне необходимо почистить все данные пользователя (SharedPreferences, Database). <br>
Этот флаг может придти в любом запросе. <br>
Получается, что необходимо в каждый Repository Inject-ить LogoutResolver или реализовать эту логику на уровне BaseRepository?<br>

**Решение**<br>

Вариант 1: <br>
Ввести декоратор для репозитория, в который инжектится все необходимое для очистки данных.  Однако, если у декоратора нет полной информации о том, как должны очищаться остальные репозитории (они могут хранить что-то в других преференсах, бд, файлах), то по-прежнему остаётся проблема того, что эти репозитории нужно как-то уведомить о необходимости очистки.<br>
Один из вариантов - создать список слушателей в декораторе, куда подключать все репозитории. В дальнейшем, если один репозиторий поймал событие о разлогине, уведомляются все репозитории-слушатели и выполняют свою логику по очистке.<br>
Недостаток: многовато кода и недостаточно легко масштабируемо.<br>

Вариант 2:<br>
Можно ввести специальную новую сущность, например, DataCleaner.<br>
Он будет инжектиться в интерсептор OkHttpClient, но при этом будет иметь доступ в БД и Преференсам, чтобы почистить их.<br>
То есть все будет разруливаться в дата слое без Репозитория и прочего.<br>
При этом, если есть, допустим, несколько файлов Преференсов, и их нужно все почистить, то для большего удобства можно ввести что-то вроде PreferencesFacade, который бы предоставлял унифицированный доступ ко всем файлам нужным. И собственно из Репозиториев тоже можно работать с преференсами через него. Тогда точно ничего не забудется.<br>

#decorator #facade #design-patterns<br>


----------

**Проблема**<br>
Есть активити с тулбаром, внутри которой переключаются фрагменты. Как из вьюшки (фрагмента) взаимодействовать с тулбаром (например поменять тайтл)?<br>

**Решение**<br>
Вариант 1:<br>
Тулбар в данном случае будет независимой вьюшкой, со своим собственным презентером. Презентер тулбара подписывается на модель (интерактор-репозиторий), которая хранит состояние тулбара. Эта модель является глобальной для всех презентеров внутри этой активити. Остальные презентеры при надобности имеют право писать в модель, а презентер тулбара должен соответственно реагировать на ее изменения.<br>

Вариант 2:<br>
Зачастую надобности в глобальном тулбаре нет. Тогда у каждого фрагмента можно сделать собственный тулбар. Поскольку в данном случае он будет являться частью текущей вьюшки, то презентер сможет обращаться к нему напрямую (например через метод во вью setTitle).<br>

#practices<br>

----------

**Проблема**<br>
Действительно ли в Чистой архитектуре нельзя в разных слоях использовать одни и те же модели данных, и их нужно перемапить, прежде чем отдать на слой выше? Не напряжно ли поддерживать такое количество классов, и не пахнет ли оно бойлерплейтом?<br>

**Решение**<br>
Чистая архитектура призывает иметь зависимости, направленные только во внутрь, а значит никто не мешает использовать Entity (бизнес сущности) в наружных слоях (например, Presentation или Data). Таким образом, в чистой архитектуре, достаточно иметь только Entities. Например, если сервер присылает данные в таком же формате, как и бизнес сущности, то особого смысла создавать новые модели данных нет, можно использовать Entitiy в качестве модели данных для сервера.  Реальная надобность в мапперах возникает тогда, когда структура данных на разных слоях должна быть разной или в моделе данных необходимо иметь платформо(фреймворк) - специфическую зависимость, например, реализовать интерфейс RealmModel.  Другой пример, в Presentation слое можно использовать бизнес сущности, но когда потребуется добавить в сущности дополнительные поля, специфические для UI (например, Color и т.д.),  то имеет смысл сделать отдельную модель для слоя представления.<br>
Итого, строго по Чистой архитектуре, достаточно иметь только Entities (бизнес сущности), которые по правилу зависимостей, можно использовать  во всех наружних слоях.<br>

#общие #чистая-архитектура<br>

----------

**Проблема**<br>
Обработка результата отдельного сценария<br>

1) Имеется экран "Список карт лояльности"<br>
2) На экране есть кнопка "Добавить новую карту"<br>
3) При нажатии кнопки открывается визард, который состоит из цепочки активити<br>
4) При прохождении сценария, нужно: <br>
 - закрыть все экраны сценария<br>
 - отобразить обновленный список карт<br>
 - показать snack уведомление, что карта добавлена<br>

**Решение**<br>
Вариант 1. <br>
Дефолтными средствами Android SDK.<br>
Реализуем старт активити с помощью startActivityForResult и в onActivityResult при необходимости делаем finish()<br>

Вариант 2. <br>
На основе Cicerone<br>
Подробности можно посмотреть в @Cicerone_RUS <br>

Вариант 3. <br>  
С использованием общего интерактора<br>
- Создаем интерактор, который доступен на экране списка карт лояльности и финальном экране визарда.<br>
- Всем активити визарда в манифесте устанавливаем значение taskAffinity как AddLoyaltyCardWizard<br>
- При добавлении карты на финальном экране происходит два действия:<br>
 1) Интерактор оповещается о добавлении карты. По этому действию он может инициировать обновление списка и отображение оповещения<br>
 2) Вызывается finishAffinity <br>

В данной реализации нужно обратить внимание на потенциальную возможность убийства активити системой.<br>

Как работает taskAffinity можно прочитать в https://developer.android.com/guide/topics/manifest/activity-element.html#aff<br>

#навигация #библиотеки<br>


----------

**Проблема**<br>
Модели данных<br>

**Решение**<br>
Репозиторий отдает уже готовые бизнес-модели. В Дате для работы с сетью, БД и т.д. используются свои модели данных. Интерактор преобразует полученные от Репозитория бизнес-модели в другие бизнес-модели (все зависит от кейсов). То есть Презентеру отдаются преобразованные бизнес-модели. Презентер же может создать свои UI-модели или просто использовать полученные. Интерактор ничего не знает о моделях данных Data или UI.<br>
Также по моделям. Чтобы уменьшить boilerplate код, можно использовать модели-обертки. Например, есть бизнес-модель, но для UI нужны дополнительные атрибуты. Тогда можно создать UI модель, в которой будет сама бизнес-модель и необходимые UI атрибуты.<br>

#repository #design-patterns #layers-architecture<br>

----------


**Проблема**<br>
Имеется репозиторий, который сливает поток сообщений из БД (приходят мгновенно) и из сети (с задержкой), презентер подписан на эти изменения (Rx). Проблема в том, что если репозиторий возвращает обсервабл с сообщениями, я не могу узнать, что произошла проблема с получением данных из сети. Если  я кину exception в момент получения данных с сети, у меня могут не сработать onNext  для сообщений с базы и они не отобразятся. Если же я просто поглощу ошибку в момент получения данных из сети, у пользователя отобразятся только закешированные данные и я не увижу, что что-то пошло не так, чтобы предупредить пользователя. <br>

**Решение** <br>
Можно сделать враппер-модель и в него записывать данные + информация о провайдере данных + ошибка, если такая была.<br>

#rx #design-patterns #error-handling<br>

----------

**Навигация**<br>
 Как лучше строить навигацию в MVP приложении? При этом если еще хотелось бы и вьюшки шарить (которые андроидовские) для использования в shared view анимации? Как реализовать навигацию, как в Инстаграм?<br>

**Решение**<br>
Как основное решение, которое подходит для большенства приложений, мы рекомендуем библиотеку [Cicerone](https://github.com/terrakok/Cicerone). Подробно с подходами, которые предложены в библиотеке можно ознамоиться на странице библиотеки на github.<br>
Также возможен вариант для простого приложения с маленьким количеством экранов. Презентер вызывает метод во View "navigateToScreen()", а в методе navigateToScreen код перехода. <br>



**Проблема**<br>
При любом запросе нам может вернуться ошибка - истекла сессия. Как это вписать в Чистую архитектуру?<br>

**Решение**<br>
Подробное решение предложено [здесь](https://github.com/AndroidArchitecture/AndroidArchitectureBook/blob/master/cases/auth/Auth_article.md)<br>

#clean-architecture #практики<br>

----------

**Проблема**<br>
 Кейс. Реализация поведения в зависимости от типа устройства.<br>

**Решение**<br>
Пускай за получение состояния - телефон или планшет, отвечает специальный репозиторий, например AppRepository, отвечающий за хранения таких вот глобальных вещей.  Ну и собственно Интерактор будет дергать данный репозиторий и решать, что делать дальше, а презентеру и вьюшке будет все равно .<br>

#repositories #практики<br>

----------

**Проблема**<br>
Типичная корзина в мобильном магазине. С корзиной приходится работать практически со всех концов приложения.<br>

**Решение**<br>
Создайте компонент BasketComponent с модулем BasketModule.<br>
В этом компоненте будет BasketInteractor и BasketRepository.<br>
Собственно эти классы будут отвечать за все расчеты и походы в сеть.<br>
Те экраны, которые будут производить манипуляцию с корзиной, будут иметь свои компоненты, дочерние по отношению к BasketComponent.<br>
Собственно в этих дочерних компонентах внутри их Интеракторов и будут дергаться нужные методы BasketInteractor.<br>
То есть логика управления корзиной будет сокрыта в BasketInteractor, а BasketInteractor будет дергаться из соответствующих интеракторов.<br>

#clean-architecture #практики #design-patterns<br>

----------

**Проблема**<br>
Всегда ли нужен Интерактор? Можно ли в Презентере использовать сразу Репозиторий, если логика предельна проста, и Интерактор в данном случае выступает просто провайдером запросов в Репозиторий?<br>

**Решение**
Интерактор нужен всегда. Большое количество мобильных приложений не имеют сложной бизнес-логики и интерактор в них будет только вызывать методы репозитория. Но есть несколько моментов в пользу подхода всегда делать интеракторы.<br>
Первый момент. Иметь отдельный класс, который инкапсулирует в себе логику получения данных очень полезно.<br>
Пример, во многих частях приложения нам необходимо получать из репозитория выбранную локаль. Мы во всех презентерах использовали напрямую репозиторий. Теперь задача поменялась, если в репозитории нет выбранной локали (пользователь еще не выбрал, почистили данные приложения и т.д.), тогда мы должны вернуть локаль по умолчанию, например Москва. Чтобы не делать это во всех презентерах, мы идем в наш репозиторий и дописываем туда код для дефолтной локали. При этом забываем, что где-то еще метод репозитория использовал другой интерактор, которому было важно знать, что пользователь еще не выбрал локаль, а теперь он этого не узнает, так как будет думать, что пользователь выбрал Москву. Если бы мы имели отдельный интерактор для получения выбранной локали, даже с одним вызовом репозитория,  то такой проблемы не было бы. <br>
Второй момент, это удобство для тех людей, которые будут работать с проектом.<br>
Представьте, у вас есть презентер, в который инжектится StoreRepository, в котором пара десятков методов. Легко сказать, что происходит в этом презентере? А если в него инжектится GetStoresByMyLocationInteractor? Во втором варианте разобраться проще, что происходит в презентере, даже несмотря на его код. И ничего страшного, что в GetStoresByMyLocationInteractor всего пара строчек кода.<br>
Третий момент, это единообразие. Мы привыкаем всегда писать отдельный класс для работы с репозиторием и вся команда использует один подход. А не два подхода, когда можно инжектить интерактор или репозиторий.<br>
Можно еще найти плюсы. А из минусов только, то что нам придется создать еще один класс, который на фоне сгенерированных даггером фабрик роли не сыграет. <br>

#CleanArchitecture #Interactor<br>
 
